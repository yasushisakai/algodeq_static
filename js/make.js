//////////////////////////////////////////////////////
// make
/////////////////////////////////////////////////////


//
// GLOBAL VARIABLES
//

// essential global variables for three.js
var canvas, camera, scene, renderer, controls, clock, projector;

// dimensions
var unit_size = 910;
var unit_height = 2550;
var resolution = 12;
var unit_length = unit_size * resolution;

// geometry
var cursor, ground;
var plan;
var geometry_data;


// document specific global variables
var new_plan_name;
var new_plan_geometry;
var new_plan_similarity;

//
// METHODS
//

function initialize() {
    // first thing done after document is ready (in the jquery manner)
    console.log("--initialize--");

    // setting things up
    // todo: maybe webGL checking?
    setup_three_js();  // renderer (DOM element), cameras, and declaring variables
    setup_world();   // entities such as lights, geometries ...etc
    setup_events();  // mouse and keyboard

    // infinite loop
    requestAnimationFrame(function animate() {
        run();
        requestAnimationFrame(animate);
    });
}

function setup_three_js() {
    console.log("--setup three js--");
    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;

    scene = new THREE.Scene();

    // todo: take care CAMERA pos and CONTROLS target
    camera = new THREE.PerspectiveCamera(
        20,
            CANVAS_WIDTH / CANVAS_HEIGHT,
        unit_size,
            unit_size * 100
    );

    camera.position = new THREE.Vector3(
            unit_length * 2.5,
            unit_length * 2.5,
            unit_length * 2.5
    );

    controls = new THREE.OrbitControls(camera);
    controls.target = new THREE.Vector3(
        0.0,
        0.0,
        0.0
    );

    clock = new THREE.Clock();
    projector = new THREE.Projector();

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true, alpha: true});
    //renderer.setClearColor(0xffffff,0);  // something is wrong with white, transparent background
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;

    // html element

    canvas = $("#webgl_canvas").prepend(renderer.domElement);
    canvas.width(CANVAS_WIDTH);
    canvas.height(CANVAS_HEIGHT);
}

function setup_world() {
    console.log("--setup world--");

    // lights

    var light = new Light();  // refer to Light.js
    light.create();

    // geometry

    geometry_data = plan_json["geometry"];  // plan_json generated by server. refer head section of make.html

    plan = new Plan(geometry_data);
    plan.create(); // generates the parents model when initialization

    // new name
    new_plan_name = random_station() + "_" + Math.floor(Math.random() * 100);

    // todo: add infinite plane (horizon) do we really need this??

    // cursor
    cursor = new Cursor();
    cursor.create();

    // base ground w/ grid
    ground = new Ground();
    ground.create();

    var axis = new Axis(unit_length * 10);
    axis.create();

    update_model_info(); // update the information
}

function setup_events() {
    console.log("--setup events--");

    // assigning the events. functions are written in 'events.js'
    renderer.domElement.addEventListener('mousemove', mouse_move, false);
    renderer.domElement.addEventListener('mousedown', mouse_down, false);
    renderer.domElement.addEventListener('keydown', key_down, false);
    renderer.domElement.addEventListener('keyup', key_up, false);

    window.addEventListener('resize', window_resize, false);

}

function run() {

    renderer.render(scene, camera);
    controls.update(clock.getDelta());

}


function save_plan(_id) {
    // saves the plan

    // update new model_name
    new_plan_name = $("*[name=new_name]").val()

    // the process is two-folded

    // first attempt validates the new model
    // todo: validation should be in javascript? the only db matter is the plan name?
    $.post("",
        {
            phase: '0',  // 0 means to validate
            new_plan_name: new_plan_name,
            new_plan_geometry: new_plan_geometry,
            new_plan_similarity: new_plan_similarity,
            csrfmiddlewaretoken: csrf_token
        },
        function (data, status) {
            var answer = JSON.parse(data);
            if (answer["is_validation"]) {
                $("div.error").text("validation");

                // validation confirmed, fetch image and save data
                $.post("",
                    {
                        phase: '1',  // 1 means to save geometry
                        new_plan_name: new_plan_name,
                        new_plan_geometry: new_plan_geometry,
                        new_plan_similarity: new_plan_similarity,
                        image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                        csrfmiddlewaretoken: csrf_token
                    },
                    function () {
                        document.location.href = "../../plan/" + new_plan_name;
                    })
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });


            } else {
                $("div.error").text(answer["message"]);
            }
        })
        .fail(function (xhr) {
            console.log("Error: " + xhr.statusText);
            alert("Error: " + xhr.statusText);
        });
    return false;
}

function change_room_type(_num) {
    Plan.room_index = _num;
}

function change_floor(_num) {
    ground.move_level_grid(_num);
    cursor.change_floor(_num);
}

function update_model_info() {

    new_plan_geometry = plan.get_rooms_json();
    new_plan_similarity = plan.compare_with(JSON.parse(geometry_data));


    // update the page info as well.
    $("*[name=new_name]").val(new_plan_name);
    $("#new_model_geometry").text(new_plan_geometry);
    $("#new_model_similarity").text(new_plan_similarity);

}