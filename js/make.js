//////////////////////////////////////////////////////
// make
/////////////////////////////////////////////////////


//
// GLOBAL VARIABLES
//

// essential global variables for three.js
var canvas, camera, scene, renderer, controls, clock, projector;

// dimensions
var unit_size = 910;
var unit_height = 2550;
var resolution = 12;
var unit_length = unit_size * resolution;

// geometry
var cursor, ground;
var plan;
var geometry_data;


// document specific global variables
// todo: add something below, THIS IS HARD CODING!!
var new_plan_name;
var new_plan_geometry;
var new_plan_similarity;

//
// METHODS
//

function initialize() {
    // first thing done after document is ready (in the jquery manner)
    console.log("--initialize--");

    // setting things up
    // todo: maybe webGL checking?
    setup_three_js();  // renderer (DOM element), cameras, and declaring variables
    setup_world();   // entities such as lights, geometries ...etc
    setup_events();  // mouse and keyboard

    // infinite loop
    // todo: try a smarter way. maybe able to shortcut 'animate'.
    requestAnimationFrame(function animate() {
        run();
        requestAnimationFrame(animate);
    });
}

function setup_three_js() {
    console.log("--setup three js--");
    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;

    // this may go to the setup_world function.
    geometry_data = plan_json["geometry"];  // plan_json generated by server. refer head section of make.html

    scene = new THREE.Scene();

    // todo: take care CAMERA pos and CONTROLS target
    camera = new THREE.PerspectiveCamera(
        20,
            CANVAS_WIDTH / CANVAS_HEIGHT,
        unit_size,
            unit_size * 100
    );

    camera.position = new THREE.Vector3(
            unit_length * 2.5,
            unit_length * 2.5,
            unit_length * 2.5
    );

    controls = new THREE.OrbitControls(camera);
    controls.target = new THREE.Vector3(
        0.0,
        0.0,
        0.0
    );

    clock = new THREE.Clock();
    projector = new THREE.Projector();

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true, alpha: true});
    //renderer.setClearColor(0xffffff,0);
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;

    // html element

    canvas = $("#webgl_canvas").prepend(renderer.domElement);
    canvas.width(CANVAS_WIDTH);
    canvas.height(CANVAS_HEIGHT);
}

function setup_world() {
    console.log("--setup world--");
    //
    // lights
    //

    var ambient = new THREE.AmbientLight(0x959f9f);
    scene.add(ambient);

    // light is same as initial camera
    var light = new THREE.DirectionalLight(0xcccccc, 1);
    light.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
    );

    // todo: fine-tune the shadows, or write it as a class?
    light.castShadow = true;
    light.shadowMapWidth = 4096;
    light.shadowMapHeight = 4096;
    var d = 1000000;
    light.shadowCameraLeft = d;
    light.shadowCameraRight = -d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;
    light.shadowCameraNear = 100000;
    light.shadowCameraFar = 2500000;
    //light.shadowCameraVisible = true;
    light.shadowBias = 0.000001;
    light.shadowDarkness = 0.2;

    scene.add(light);

    //
    // geometry
    //

    plan = new Plan(geometry_data); // generates the parents model when initialization
    new_plan_geometry = plan.get_rooms_json();
    $("#new_model_geometry").text(new_plan_geometry);  // todo: this is also kind of stupid in a way...

    // todo: add infinite plane (horizon) do we need this??

    // cursor
    cursor = new Cursor();
    cursor.create();

    // base ground
    ground = new Ground();
    ground.create();

    var axis = new Axis(unit_length * 10);
    axis.create();
}

function setup_events() {
    console.log("--setup events--");

    var intersect_objects;

    renderer.domElement.addEventListener('mousemove', function (event) {

        event.preventDefault();
        var vector = new THREE.Vector3(
                renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
            0
        );

        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(
            camera.position,
            vector.sub(camera.position).normalize()
        );

        intersect_objects = raycaster.intersectObjects(scene.children);

        //if (intersect_objects.length > 0 && intersect_objects[0].object.name == "grid") {
        if (intersect_objects.length > 0) {
            var flag = false;
            var i;
            for (i = 0; i < intersect_objects.length; i++) {
                if (intersect_objects[i].object.name == "grid") {
                    flag = true;
                    break;
                }
            }
            if (flag) {
                if (Math.abs(ground.get_level_height() - intersect_objects[i].point.y) < 1) {
                    var int_point = intersect_objects[i].point;
                    int_point.y = ground.get_level_height();  // over write height to clean value
                    if (cursor.check_position(int_point)) {
                        cursor.index_from_pos(int_point);
                        cursor.update_pos();
                    }
                }
            }
        }


    });

    renderer.domElement.addEventListener('mousedown', function (event) {
        if (Plan.room_index != 6) {  // 6 is deleting cubes
            // add a cube if the cursor is in boundary and there is no rooms extant
            if (cursor.is_valid && plan.check_room_duplicates(cursor.get_index())) {
                plan.add_room(cursor.get_index());
            }
        } else {
            if (cursor.is_valid) {
                plan.remove_room(cursor.get_index());
            }
        }


        $("#new_model_geometry").text(plan.get_rooms_json());  // todo: this is not smart
        new_plan_geometry = plan.get_rooms_json();

        var similarity = plan.compare_with(JSON.parse(geometry_data));
        $("#new_model_similarity").text("" + similarity);
        new_plan_similarity = similarity;

    });


}

function run() {
    renderer.render(scene, camera);
    controls.update(clock.getDelta());
}


function save_plan(_id) {
    // saves the plan
    // the process is two-folded

    new_plan_name = random_station() + "_" + Math.floor(Math.random() * 100);

    // first attempt validates the new model
    $.post("",
        {
            phase: '0',  // 0 means to validate
            new_plan_name: new_plan_name,
            new_plan_geometry: new_plan_geometry,
            new_plan_similarity: new_plan_similarity,
            csrfmiddlewaretoken: csrf_token
        },
        function (data, status) {
            var answer = JSON.parse(data);
            if (answer["is_validation"]) {
                $("div.error").text("validation");

                // validation confirmed, fetch image and save data
                $.post("",
                    {
                        phase: '1',  // 1 means to save geometry
                        new_plan_name: new_plan_name,
                        new_plan_geometry: new_plan_geometry,
                        new_plan_similarity: new_plan_similarity,
                        image: renderer.domElement.toDataURL().replace("data:image/png;base64,", ""),
                        csrfmiddlewaretoken: csrf_token
                    },
                    function () {
                        document.location.href = "../../plan/" + new_plan_name;
                    })
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });


            } else {
                $("div.error").text(answer["message"]);
            }
        })
        .fail(function (xhr) {
            console.log("Error: " + xhr.statusText);
            alert("Error: " + xhr.statusText);
        });
    return false;
}


function change_room_type(_num) {
    Plan.room_index = _num;
}

function change_floor(_num) {
    ground.move_level_grid(_num);
    cursor.change_floor(_num);
}