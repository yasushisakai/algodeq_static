//////////////////////////////////////////////////////
// make
/////////////////////////////////////////////////////


//
// GLOBAL VARIABLES
//

// essential global variables for three.js
var canvas, camera, scene, renderer, controls, clock, projector;

// dimensions
var unit_size = 910;
var unit_height = 2550;
var resolution = 12;
var unit_length = unit_size * resolution;
var max_floor = 3;

// geometry
var cursor,ground;
var plan;
var geometry_data;


// document specific global variables
// todo: add something below, THIS IS HARD CODING!!
var new_plan_name;
var new_plan_geometry=plan_json["geometry"];
var new_plan_similarity;
var room_type=0;

//
// METHODS
//

function initialize() {
    // first thing done after document is ready (in the jquery manner)
    console.log("--initialize--");

    // setting things up
    // todo: maybe webGL checking?
    setup_three_js();  // renderer (DOM element), cameras, and declaring variables
    setup_world();   // entities such as lights, geometries ...etc
    setup_events();  // mouse and keyboard

    // infinite loop
    // todo: try a smarter way. maybe able to shortcut 'animate'.
    requestAnimationFrame(function animate() {
        run();
        requestAnimationFrame(animate);
    });
}

function setup_three_js() {
    console.log("--setup three js--");
    var CANVAS_WIDTH = window.innerWidth;
    var CANVAS_HEIGHT = window.innerHeight;

    // todo: valid geometry data needed.
    // this may go to the setup_world function.
    geometry_data = plan_json["geometry"];  // plan_json generated by server. refer head section of make.html

    scene = new THREE.Scene();

    // todo: take care CAMERA pos and CONTROLS target
    camera = new THREE.PerspectiveCamera(
        20,
            CANVAS_WIDTH / CANVAS_HEIGHT,
        unit_size,
            unit_size * 100
    );

    camera.position = new THREE.Vector3(
            unit_length * 2.5,
            unit_length * 2.5,
            unit_length * 2.5
    );

    controls = new THREE.OrbitControls(camera);
    controls.target = new THREE.Vector3(
        0.0,
        0.0,
        0.0
    );

    clock = new THREE.Clock();
    projector = new THREE.Projector();

    renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: true});
    renderer.setSize(CANVAS_WIDTH, CANVAS_HEIGHT);
    renderer.shadowMapEnabled = true;

    // html element

    canvas = $("#webgl_canvas").prepend(renderer.domElement);
    canvas.width(CANVAS_WIDTH);
    canvas.height(CANVAS_HEIGHT);
}

function setup_world() {
    console.log("--setup world--");
    //
    // lights
    //

    var ambient = new THREE.AmbientLight(0x959f9f);
    scene.add(ambient);

    // light is same as initial camera
    var light = new THREE.DirectionalLight(0xcccccc, 1);
    light.position.set(
        camera.position.x,
        camera.position.y,
        camera.position.z
    );

    // todo: fine-tune the shadows, or write it as a class?
    light.castShadow = true;
    light.shadowMapWidth = 4096;
    light.shadowMapHeight = 4096;
    var d = 1000000;
    light.shadowCameraLeft = d;
    light.shadowCameraRight = -d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;
    light.shadowCameraNear = 100000;
    light.shadowCameraFar = 2500000;
    //light.shadowCameraVisible = true;
    light.shadowBias = 0.000001;
    light.shadowDarkness = 0.2;

    scene.add(light);

    //
    // geometry
    //

    // todo: generate main plan geometry
    plan = new Plan(new_plan_geometry);

    // todo: add infinite plane (horizon)

    // cursor
    cursor = new Cursor();
    cursor.create();

    // base ground
    ground = new Ground();
    ground.create();

    var axis = new Axis(unit_length * 10);
    axis.create();
}

function setup_events() {
    console.log("--setup events--");

    var intersect_objects;

    renderer.domElement.addEventListener('mousemove', function (event) {

        event.preventDefault();
        var vector = new THREE.Vector3(
                renderer.devicePixelRatio * (event.pageX - this.offsetLeft) / this.width * 2 - 1,
                -renderer.devicePixelRatio * (event.pageY - this.offsetTop) / this.height * 2 + 1,
            0
        );

        projector.unprojectVector(vector, camera);

        var raycaster = new THREE.Raycaster(
            camera.position,
            vector.sub(camera.position).normalize()
        );

        intersect_objects = raycaster.intersectObjects(scene.children);

        if (intersect_objects.length > 0 && intersect_objects[0].object.name == "grid") {
            if (Math.abs(ground.get_level_height() - intersect_objects[0].point.y) < 1) {
                var int_point = intersect_objects[0].point;
                int_point.y = ground.get_level_height();  // over write height to clean value
                console.log(intersect_objects[0]);
                if (cursor.check_position(int_point)) {
                    cursor.index_from_pos(int_point);
                    cursor.update_pos();
                }
            }
        }


    });

    renderer.domElement.addEventListener('mousedown', function (event) {

        // add a cube if the cursor is in boundary and there is no rooms extant
        if(cursor.is_valid && plan.check_room_duplicates(cursor.get_index())){
            var cube = new Cube(cursor.get_index(),room_type);
            cube.create();
            cube.update_pos();
        }

        $("#new_model_info").text(plan.get_rooms_json());
        new_plan_geometry = plan.get_rooms_json();

    });
}

function run() {
    renderer.render(scene, camera);
    controls.update(clock.getDelta());
}


function save_plan(_id) {
    // saves the plan
    // the process is two-folded

    new_plan_name = random_station()+"_"+Math.floor(Math.random()*100);
    new_plan_similarity = Math.random();

    // first attempt validates the new model
    $.post("",
        {
            phase: '0',  // 0 means to validate
            new_plan_name: new_plan_name,
            new_plan_geometry: new_plan_geometry,
            new_plan_similarity: new_plan_similarity,
            csrfmiddlewaretoken: csrf_token
        },
        function (data, status) {
            var answer = JSON.parse(data);
            if (answer["is_validation"]) {
                $("div.error").text("validation");

                // validation confirmed, fetch image and save data
                $.post("",
                    {
                        phase: '1',  // 1 means to save geometry
                        new_plan_name: new_plan_name,
                        new_plan_geometry: new_plan_geometry,
                        new_plan_similarity: new_plan_similarity,
                        // todo: fetch the image here
                        csrfmiddlewaretoken: csrf_token
                    },
                    function () {
                        document.location.href = "../../plan/" + new_plan_name;
                    })
                    .fail(function (xhr) {
                        console.log("Error: " + xhr.statusText);
                        alert("Error: " + xhr.statusText);
                    });


            } else {
                $("div.error").text(answer["message"]);
            }
        })
        .fail(function (xhr) {
            console.log("Error: " + xhr.statusText);
            alert("Error: " + xhr.statusText);
        });
    return false;
}

function change_room_type(_num){
    room_type = _num;
    console.log(room_type);
}

function change_floor(_num){
    ground.move_level_grid(_num);
    cursor.change_floor(_num);
}